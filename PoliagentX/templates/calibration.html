{% extends "base.html" %}
{% load static %}

{% block content %}
<div class="min-h-screen bg-white py-12 px-4 sm:px-6 lg:px-8">
  <div class="max-w-7xl mx-auto space-y-8">

    <div class="bg-white shadow-lg rounded-xl p-6 mb-6">
      <h1 class="text-4xl font-bold text-black mb-4">Calibration</h1>
      <p class="text-[#0b0b0b] mb-4 leading-relaxed">
        This step allows you to calibrate the model parameters.
        Move the slider to set the calibration threshold and press
        ‚ÄúStart Calibration‚Äù.
      </p>
    </div>

    <div>
      <form id="calibration-form" method="POST" action="{% url 'start_calibration' %}"
        class="bg-white rounded-lg p-6 shadow-md space-y-6">
        {% csrf_token %}
        <h1 class="text-xl font-semibold">Calibration quality</h1>
        <p class="text-lg text-[#0b0b0b] leading-relaxed">
          You can determine how good the calibration quality should be. The higher the quality, the more time it takes to calibrate the model. If the calibration is taking too long, you can reset it and choose a lower quality. For quick tests, it is advisable to use a quality value around 0.3. Once you are sure about the type of exercise and the data that you plan to use, you can calibrate the model at a higher quality. A quality of 1 is theoretically the highest, but it is unachievable in practical terms due to the stochasticity of the model.
        </p>

        <div class="text-center space-y-2">
          <div id="slider-value" class="text-xl font-semibold text-black">0.50</div>
          <input type="range" id="slider" name="threshold"
            min="0.05" max="0.99" step="0.01" value="0.70"
            class="w-full h-2 bg-black rounded appearance-none focus:outline-none">
        </div>

          <button id="start-calibration-button" type="submit"
          class="w-full bg-gradient-to-r from-green-600/10 to-green-600/20 backdrop-blur-md 
          text-black py-2 font-medium">
          START CALIBRATION
        </button>
      </form>
    </div>

    <div class="bg-white shadow-lg rounded-xl p-6 mb-6  text-right">
      <div id="next-button-container" class="hidden">
        <a href="{% url 'simulation' %}"
          class="inline-block px-6 py-2 bg-green-600 text-white font-semibold rounded hover:bg-green-700">
          NEXT ‚Üí
        </a>
      </div>
      <div id="next-disabled">
        <button disabled
          class="inline-block px-6 py-2 bg-gray-400 text-white font-semibold rounded cursor-not-allowed">
          NEXT ‚Üí
        </button>
      </div>
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const slider = document.getElementById('slider');
    const sliderValueDisplay = document.getElementById('slider-value');
    const calibrationForm = document.getElementById('calibration-form');
    const startCalibrationButton = document.getElementById('start-calibration-button');
    const nextButtonContainer = document.getElementById('next-button-container');
    const nextDisabled = document.getElementById('next-disabled');
    const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;

    // Initialize slider value display
    sliderValueDisplay.textContent = parseFloat(slider.value).toFixed(2);

    slider.addEventListener('input', function() {
      sliderValueDisplay.textContent = parseFloat(this.value).toFixed(2);
    });

    // ‚úÖ Handle calibration form submission
    calibrationForm.addEventListener('submit', async function(event) {
      event.preventDefault();
      console.log("Calibration form submitted üöÄ");

      startCalibrationButton.disabled = true;
      startCalibrationButton.textContent = "Calibrating...";

      try {
        const formData = new FormData(calibrationForm);
        const response = await fetch(calibrationForm.action, {
          method: 'POST',
          headers: { 'X-CSRFToken': csrfToken },
          body: formData
        });

        console.log("Raw response:", response);

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        console.log("Parsed JSON:", result);

        if (result.success) {
          console.log("Calibration success ‚úÖ", result);
          nextDisabled.classList.add('hidden');
          nextButtonContainer.classList.remove('hidden');
          alert(result.message);
        } else {
          alert('Calibration failed: ' + result.message);
        }

      } catch (error) {
        console.error("Error during calibration:", error);
        alert('An error occurred during calibration. Please try again.');
      } finally {
        startCalibrationButton.disabled = false;
        startCalibrationButton.textContent = "START CALIBRATION";
      }
    });

    // Keep NEXT disabled initially
    nextButtonContainer.classList.add('hidden');
    nextDisabled.classList.remove('hidden');
  });
</script>


{% endblock %}
